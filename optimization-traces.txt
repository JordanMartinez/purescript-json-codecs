== Snapshot.ToRecordInlines ====================================================
================================================================================

++ Snapshot.ToRecordInlines.decoder Step 1 (Original) ++++++++++++++++++++++++++
  Snapshot.ToRecordInlines.toRecord
    ( Codec.Json.Unidirectional.Value.toRecordObjCons
      ( Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Snapshot.ToRecordInlines.toRecordObjCons
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined]
      )
      { "reflectSymbol": \_ -> "nested" }
      #[prim.undefined]
      #[prim.undefined]
      #[prim.undefined]
    )
    { "req":
        Codec.Json.Unidirectional.Value.toRequired
          Codec.Json.Unidirectional.Value.toInt
    , "reqRen":
        Codec.Json.Unidirectional.Value.toRequiredRename
          "otherName"
          Codec.Json.Unidirectional.Value.toString
    , "opt":
        Codec.Json.Unidirectional.Value.toOption
          Codec.Json.Unidirectional.Value.toString
    , "optRen":
        Codec.Json.Unidirectional.Value.toOptionRename
          "otherName2"
          Codec.Json.Unidirectional.Value.toString
    , "optArr":
        Codec.Json.Unidirectional.Value.toOptionArray
          Codec.Json.Unidirectional.Value.toString
    , "nested":
        Codec.Json.Unidirectional.Value.toRequired
          ( Snapshot.ToRecordInlines.toRecord
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Snapshot.ToRecordInlines.toRecordObjCons
                { "reflectSymbol": \_ -> "other" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "foo" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "other":
                Codec.Json.Unidirectional.Value.toRequired
                  Codec.Json.Unidirectional.Value.toBoolean
            , "foo":
                Codec.Json.Unidirectional.Value.toOption
                  Codec.Json.Unidirectional.Value.toBoolean
            }
          )
    }

-- Snapshot.ToRecordInlines.decoder Step 2 -------------------------------------
  {- Inline -}
  let @0 = #[prim.undefined] in
  let
    @1 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                ( Codec.Json.Unidirectional.Value.toRecordObjCons
                  Codec.Json.Unidirectional.Value.toRecordObjNil
                  { "reflectSymbol": \_ -> "reqRen" }
                  #[prim.undefined]
                  #[prim.undefined]
                  #[prim.undefined]
                )
                { "reflectSymbol": \_ -> "req" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "optRen" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optArr" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "opt" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "nested" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  {- Inline -}
  let
    @2 =
      {- Inline -}
      let
        @2 =
          \codecs@2 ->
            let @3 = @1."toRecordObj" Type.Proxy.Proxy codecs@2 in
            \a@4 ->
              let @5 = Codec.Json.Unidirectional.Value.toJObject a@4 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left(@5#0)
              else if #[prim.istag Data.Either.Right](@5) then@3 @5#0
              else 
                #[prim.fail]() in
      @2 in
  @2
    { "req":
        \(lookupFn@3, recLabel@4) ->
          let v@5 = lookupFn@3 recLabel@4 in
          if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Left
              ( Codec.Json.Unidirectional.Value.AtKey
                ( recLabel@4
                , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                )
              )
          else if #[prim.istag Data.Maybe.Just](v@5) thenlet
              @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
            let @7 = Codec.Json.Unidirectional.Value.toInt v@5#0 in
            if #[prim.istag Data.Either.Left](@7) thenData.Either.Left(@6 @7#0)
            else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                (@7#0)
            else 
              #[prim.fail]()
          else 
            #[prim.fail]()
    , "reqRen":
        {- Inline -}
        let @3 = "otherName" in
        {- Inline -}
        let
          @4 =
            \(lookupFn@4, v@5) ->
              let v1@6 = lookupFn@4 @3 in
              if #[prim.istag Data.Maybe.Nothing](v1@6) thenData.Either.Left
                  ( Codec.Json.Unidirectional.Value.AtKey
                    ( @3
                    , Codec.Json.Unidirectional.Value.DecodeError
                      ("Missing field")
                    )
                  )
              else if #[prim.istag Data.Maybe.Just](v1@6) thenlet
                  @7 = Codec.Json.Unidirectional.Value.AtKey @3 in
                let @8 = Codec.Json.Unidirectional.Value.toString v1@6#0 in
                if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                    (@7 @8#0)
                else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                    (@8#0)
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]() in
        @4
    , "opt":
        \(lookupFn@3, recLabel@4) ->
          let v@5 = lookupFn@3 recLabel@4 in
          if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Right
              (Data.Maybe.Nothing)
          else if #[prim.istag Data.Maybe.Just](v@5) thenlet
              @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
            let @7 = Codec.Json.Unidirectional.Value.toString v@5#0 in
            if #[prim.istag Data.Either.Left](@7) thenData.Either.Left(@6 @7#0)
            else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                (Data.Maybe.Just(@7#0))
            else 
              #[prim.fail]()
          else 
            #[prim.fail]()
    , "optRen":
        {- Inline -}
        let @3 = "otherName2" in
        {- Inline -}
        let
          @4 =
            \(lookupFn@4, v@5) ->
              let v1@6 = lookupFn@4 @3 in
              if #[prim.istag Data.Maybe.Nothing](v1@6) thenData.Either.Right
                  (Data.Maybe.Nothing)
              else if #[prim.istag Data.Maybe.Just](v1@6) thenlet
                  @7 = Codec.Json.Unidirectional.Value.AtKey @3 in
                let @8 = Codec.Json.Unidirectional.Value.toString v1@6#0 in
                if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                    (@7 @8#0)
                else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                    (Data.Maybe.Just(@8#0))
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]() in
        @4
    , "optArr":
        \(lookupFn@3, recLabel@4) ->
          let v@5 = lookupFn@3 recLabel@4 in
          if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Right([])
          else if #[prim.istag Data.Maybe.Just](v@5) thenlet
              @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
            let
              @7 =
                Codec.Json.Unidirectional.Value.toArray
                  Codec.Json.Unidirectional.Value.toString
                  v@5#0 in
            if #[prim.istag Data.Either.Left](@7) thenData.Either.Left(@6 @7#0)
            else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                (@7#0)
            else 
              #[prim.fail]()
          else 
            #[prim.fail]()
    , "nested":
        {- Inline -}
        let @3 = #[prim.undefined] in
        let
          @4 =
            Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "other" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "foo" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined] in
        {- Inline -}
        let
          @5 =
            \codecs@5 ->
              let @6 = @4."toRecordObj" Type.Proxy.Proxy codecs@5 in
              \a@7 ->
                let @8 = Codec.Json.Unidirectional.Value.toJObject a@7 in
                if #[prim.istag Data.Either.Left](@8) thenData.Either.Left(@8#0)
                else if #[prim.istag Data.Either.Right](@8) then@6 @8#0
                else 
                  #[prim.fail]() in
        let
          @6 =
            @5
              { "other":
                  \(lookupFn@6, recLabel@7) ->
                    let v@8 = lookupFn@6 recLabel@7 in
                    if #[prim.istag Data.Maybe.Nothing](v@8) thenData.Either.Left
                        ( Codec.Json.Unidirectional.Value.AtKey
                          ( recLabel@7
                          , Codec.Json.Unidirectional.Value.DecodeError
                            ("Missing field")
                          )
                        )
                    else if #[prim.istag Data.Maybe.Just](v@8) thenlet
                        @9 = Codec.Json.Unidirectional.Value.AtKey recLabel@7 in
                      let
                        @10 = Codec.Json.Unidirectional.Value.toBoolean v@8#0 in
                      if #[prim.istag Data.Either.Left](@10) thenData.Either.Left
                          (@9 @10#0)
                      else if #[prim.istag Data.Either.Right](@10) thenData.Either.Right
                          (@10#0)
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              , "foo":
                  \(lookupFn@6, recLabel@7) ->
                    let v@8 = lookupFn@6 recLabel@7 in
                    if #[prim.istag Data.Maybe.Nothing](v@8) thenData.Either.Right
                        (Data.Maybe.Nothing)
                    else if #[prim.istag Data.Maybe.Just](v@8) thenlet
                        @9 = Codec.Json.Unidirectional.Value.AtKey recLabel@7 in
                      let
                        @10 = Codec.Json.Unidirectional.Value.toBoolean v@8#0 in
                      if #[prim.istag Data.Either.Left](@10) thenData.Either.Left
                          (@9 @10#0)
                      else if #[prim.istag Data.Either.Right](@10) thenData.Either.Right
                          (Data.Maybe.Just(@10#0))
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              } in
        {- Inline -}
        let
          @7 =
            \(lookupFn@7, recLabel@8) ->
              let v@9 = lookupFn@7 recLabel@8 in
              if #[prim.istag Data.Maybe.Nothing](v@9) thenData.Either.Left
                  ( Codec.Json.Unidirectional.Value.AtKey
                    ( recLabel@8
                    , Codec.Json.Unidirectional.Value.DecodeError
                      ("Missing field")
                    )
                  )
              else if #[prim.istag Data.Maybe.Just](v@9) thenlet
                  @10 = Codec.Json.Unidirectional.Value.AtKey recLabel@8 in
                let @11 = @6 v@9#0 in
                if #[prim.istag Data.Either.Left](@11) thenData.Either.Left
                    (@10 @11#0)
                else if #[prim.istag Data.Either.Right](@11) thenData.Either.Right
                    (@11#0)
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]() in
        @7
    }

-- Snapshot.ToRecordInlines.decoder Step 3 -------------------------------------
  {- Inline -}
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                ( Codec.Json.Unidirectional.Value.toRecordObjCons
                  Codec.Json.Unidirectional.Value.toRecordObjNil
                  { "reflectSymbol": \_ -> "reqRen" }
                  #[prim.undefined]
                  #[prim.undefined]
                  #[prim.undefined]
                )
                { "reflectSymbol": \_ -> "req" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "optRen" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optArr" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "opt" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "nested" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  {- Inline -}
  let
    @1 =
      { "req":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@2
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toInt v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "reqRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( "otherName"
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "opt":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toString v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName2" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optArr":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right([])
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let
                @5 =
                  Codec.Json.Unidirectional.Value.toArray
                    Codec.Json.Unidirectional.Value.toString
                    v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "nested":
          {- Inline -}
          let
            @1 =
              Codec.Json.Unidirectional.Value.toRecordObjCons
                ( Codec.Json.Unidirectional.Value.toRecordObjCons
                  Codec.Json.Unidirectional.Value.toRecordObjNil
                  { "reflectSymbol": \_ -> "other" }
                  #[prim.undefined]
                  #[prim.undefined]
                  #[prim.undefined]
                )
                { "reflectSymbol": \_ -> "foo" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined] in
          {- Inline -}
          let
            @2 =
              { "other":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Left
                        ( Codec.Json.Unidirectional.Value.AtKey
                          ( recLabel@3
                          , Codec.Json.Unidirectional.Value.DecodeError
                            ("Missing field")
                          )
                        )
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (@6#0)
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              , "foo":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                        (Data.Maybe.Nothing)
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (Data.Maybe.Just(@6#0))
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              } in
          let
            @3 =
              let @3 = @1."toRecordObj" Type.Proxy.Proxy @2 in
              {- Inline -}
              let
                @4 =
                  \a@4 ->
                    let @5 = Codec.Json.Unidirectional.Value.toJObject a@4 in
                    if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                        (@5#0)
                    else if #[prim.istag Data.Either.Right](@5) then@3 @5#0
                    else 
                      #[prim.fail]() in
              @4 in
          \(lookupFn@4, recLabel@5) ->
            let v@6 = lookupFn@4 recLabel@5 in
            if #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@5
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@6) thenlet
                @7 = Codec.Json.Unidirectional.Value.AtKey recLabel@5 in
              let @8 = @3 v@6#0 in
              if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                  (@7 @8#0)
              else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                  (@8#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      } in
  let @2 = @0."toRecordObj" Type.Proxy.Proxy @1 in
  {- Inline -}
  let
    @3 =
      \a@3 ->
        let @4 = Codec.Json.Unidirectional.Value.toJObject a@3 in
        if #[prim.istag Data.Either.Left](@4) thenData.Either.Left(@4#0)
        else if #[prim.istag Data.Either.Right](@4) then@2 @4#0
        else 
          #[prim.fail]() in
  @3

-- Snapshot.ToRecordInlines.decoder Step 4 -------------------------------------
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  let
    @1 =
      {- Inline -}
      let
        @1 =
          ( {- UnpackRecord -}
          let @1 = { "reflectSymbol": \_ -> "nested" } in
          {- Inline -}
          let @2 = #[prim.undefined] in
          {- Inline -}
          let @3 = #[prim.undefined] in
          {- Inline -}
          let @4 = #[prim.undefined] in
          { "toRecordObj":
              \v@5 codecs@6 j@7 ->
                let lbl@8 = @1."reflectSymbol" Type.Proxy.Proxy in
                let
                  @9 =
                    Record.Unsafe.unsafeGet
                      (@1."reflectSymbol" Type.Proxy.Proxy)
                      codecs@6 in
                let @10 = @0."toRecordObj" Type.Proxy.Proxy codecs@6 j@7 in
                if #[prim.istag Data.Either.Left](@10) thenlet
                    v2@11 =
                      @9
                        ( \k@11 ->
                          Foreign.Object._lookup
                            (Data.Maybe.Nothing, Data.Maybe.Just, k@11, j@7)
                        , lbl@8
                        ) in
                  if #[prim.istag Data.Either.Left](v2@11) thenData.Either.Left
                      ( if
                        #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                          (@10#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                          (Data.List.Types.Cons(v2@11#0, @10#0#0))
                      else 
                        Codec.Json.Unidirectional.Value.AccumulateError
                          ( Data.List.Types.Cons
                            ( v2@11#0
                            , Data.List.Types.Cons(@10#0, Data.List.Types.Nil)
                            )
                          )
                      )
                  else 
                    Data.Either.Left(@10#0)
                else if #[prim.istag Data.Either.Right](@10) then( if
                    #[prim.istag Data.Either.Left](@10) thenlet @11 = @10#0 in
                    \v@12 -> Data.Either.Left(@11)
                  else if #[prim.istag Data.Either.Right](@10) thenlet
                      @11 = @10#0 in
                    \f@12 -> f@12 @11
                  else 
                    #[prim.fail]()
                  )
                    ( \rec@11 ->
                      let
                        @12 =
                          @9
                            ( \k@12 ->
                              Foreign.Object._lookup
                                (Data.Maybe.Nothing, Data.Maybe.Just, k@12, j@7)
                            , lbl@8
                            ) in
                      ( if #[prim.istag Data.Either.Left](@12) thenlet
                          @13 = @12#0 in
                        \v@14 -> Data.Either.Left(@13)
                      else if #[prim.istag Data.Either.Right](@12) thenlet
                          @13 = @12#0 in
                        \f@14 -> f@14 @13
                      else 
                        #[prim.fail]()
                      )
                        ( \a@13 ->
                          Data.Either.Right
                            ( Record.Unsafe.unsafeSet
                              (@1."reflectSymbol" Type.Proxy.Proxy)
                              a@13
                              rec@11
                            )
                        )
                    )
                else 
                  #[prim.fail]()
          }
          )."toRecordObj" in
      {- Inline -}
      let
        @2 =
          @1
            Type.Proxy.Proxy
            { "req":
                \(lookupFn@2, recLabel@3) ->
                  let v@4 = lookupFn@2 recLabel@3 in
                  if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Left
                      ( Codec.Json.Unidirectional.Value.AtKey
                        ( recLabel@3
                        , Codec.Json.Unidirectional.Value.DecodeError
                          ("Missing field")
                        )
                      )
                  else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                      @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                    let @6 = Codec.Json.Unidirectional.Value.toInt v@4#0 in
                    if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                        (@5 @6#0)
                    else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                        (@6#0)
                    else 
                      #[prim.fail]()
                  else 
                    #[prim.fail]()
            , "reqRen":
                \(lookupFn@2, v@3) ->
                  let v1@4 = lookupFn@2 "otherName" in
                  if #[prim.istag Data.Maybe.Nothing](v1@4) thenData.Either.Left
                      ( Codec.Json.Unidirectional.Value.AtKey
                        ( "otherName"
                        , Codec.Json.Unidirectional.Value.DecodeError
                          ("Missing field")
                        )
                      )
                  else if #[prim.istag Data.Maybe.Just](v1@4) thenlet
                      @5 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
                    let @6 = Codec.Json.Unidirectional.Value.toString v1@4#0 in
                    if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                        (@5 @6#0)
                    else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                        (@6#0)
                    else 
                      #[prim.fail]()
                  else 
                    #[prim.fail]()
            , "opt":
                \(lookupFn@2, recLabel@3) ->
                  let v@4 = lookupFn@2 recLabel@3 in
                  if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                      (Data.Maybe.Nothing)
                  else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                      @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                    let @6 = Codec.Json.Unidirectional.Value.toString v@4#0 in
                    if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                        (@5 @6#0)
                    else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                        (Data.Maybe.Just(@6#0))
                    else 
                      #[prim.fail]()
                  else 
                    #[prim.fail]()
            , "optRen":
                \(lookupFn@2, v@3) ->
                  let v1@4 = lookupFn@2 "otherName2" in
                  if #[prim.istag Data.Maybe.Nothing](v1@4) thenData.Either.Right
                      (Data.Maybe.Nothing)
                  else if #[prim.istag Data.Maybe.Just](v1@4) thenlet
                      @5 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
                    let @6 = Codec.Json.Unidirectional.Value.toString v1@4#0 in
                    if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                        (@5 @6#0)
                    else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                        (Data.Maybe.Just(@6#0))
                    else 
                      #[prim.fail]()
                  else 
                    #[prim.fail]()
            , "optArr":
                \(lookupFn@2, recLabel@3) ->
                  let v@4 = lookupFn@2 recLabel@3 in
                  if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                      ([])
                  else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                      @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                    let
                      @6 =
                        Codec.Json.Unidirectional.Value.toArray
                          Codec.Json.Unidirectional.Value.toString
                          v@4#0 in
                    if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                        (@5 @6#0)
                    else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                        (@6#0)
                    else 
                      #[prim.fail]()
                  else 
                    #[prim.fail]()
            , "nested":
                let
                  @2 =
                    Codec.Json.Unidirectional.Value.toRecordObjCons
                      Codec.Json.Unidirectional.Value.toRecordObjNil
                      { "reflectSymbol": \_ -> "other" }
                      #[prim.undefined]
                      #[prim.undefined]
                      #[prim.undefined] in
                let
                  @3 =
                    let
                      @3 =
                        {- Inline -}
                        let
                          @3 =
                            ( {- UnpackRecord -}
                            let @3 = { "reflectSymbol": \_ -> "foo" } in
                            {- Inline -}
                            let @4 = #[prim.undefined] in
                            {- Inline -}
                            let @5 = #[prim.undefined] in
                            {- Inline -}
                            let @6 = #[prim.undefined] in
                            { "toRecordObj":
                                \v@7 codecs@8 j@9 ->
                                  let
                                    lbl@10 = @3."reflectSymbol" Type.Proxy.Proxy in
                                  let
                                    @11 =
                                      Record.Unsafe.unsafeGet
                                        (@3."reflectSymbol" Type.Proxy.Proxy)
                                        codecs@8 in
                                  let
                                    @12 =
                                      @2."toRecordObj"
                                        Type.Proxy.Proxy
                                        codecs@8
                                        j@9 in
                                  if #[prim.istag Data.Either.Left](@12) thenlet
                                      v2@13 =
                                        @11
                                          ( \k@13 ->
                                            Foreign.Object._lookup
                                              ( Data.Maybe.Nothing
                                              , Data.Maybe.Just
                                              , k@13
                                              , j@9
                                              )
                                          , lbl@10
                                          ) in
                                    if
                                      #[prim.istag Data.Either.Left](v2@13) thenData.Either.Left
                                        ( if
                                          #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                                            (@12#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                                            ( Data.List.Types.Cons
                                              (v2@13#0, @12#0#0)
                                            )
                                        else 
                                          Codec.Json.Unidirectional.Value.AccumulateError
                                            ( Data.List.Types.Cons
                                              ( v2@13#0
                                              , Data.List.Types.Cons
                                                (@12#0, Data.List.Types.Nil)
                                              )
                                            )
                                        )
                                    else 
                                      Data.Either.Left(@12#0)
                                  else if
                                    #[prim.istag Data.Either.Right](@12) then( if
                                      #[prim.istag Data.Either.Left](@12) thenlet
                                        @13 = @12#0 in
                                      \v@14 -> Data.Either.Left(@13)
                                    else if
                                      #[prim.istag Data.Either.Right](@12) thenlet
                                        @13 = @12#0 in
                                      \f@14 -> f@14 @13
                                    else 
                                      #[prim.fail]()
                                    )
                                      ( \rec@13 ->
                                        let
                                          @14 =
                                            @11
                                              ( \k@14 ->
                                                Foreign.Object._lookup
                                                  ( Data.Maybe.Nothing
                                                  , Data.Maybe.Just
                                                  , k@14
                                                  , j@9
                                                  )
                                              , lbl@10
                                              ) in
                                        ( if
                                          #[prim.istag Data.Either.Left](@14) thenlet
                                            @15 = @14#0 in
                                          \v@16 -> Data.Either.Left(@15)
                                        else if
                                          #[prim.istag Data.Either.Right](@14) thenlet
                                            @15 = @14#0 in
                                          \f@16 -> f@16 @15
                                        else 
                                          #[prim.fail]()
                                        )
                                          ( \a@15 ->
                                            Data.Either.Right
                                              ( Record.Unsafe.unsafeSet
                                                ( @3."reflectSymbol"
                                                  Type.Proxy.Proxy
                                                )
                                                a@15
                                                rec@13
                                              )
                                          )
                                      )
                                  else 
                                    #[prim.fail]()
                            }
                            )."toRecordObj" in
                        {- Inline -}
                        let
                          @4 =
                            @3
                              Type.Proxy.Proxy
                              { "other":
                                  \(lookupFn@4, recLabel@5) ->
                                    let v@6 = lookupFn@4 recLabel@5 in
                                    if
                                      #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Left
                                        ( Codec.Json.Unidirectional.Value.AtKey
                                          ( recLabel@5
                                          , Codec.Json.Unidirectional.Value.DecodeError
                                            ("Missing field")
                                          )
                                        )
                                    else if
                                      #[prim.istag Data.Maybe.Just](v@6) thenlet
                                        @7 =
                                          Codec.Json.Unidirectional.Value.AtKey
                                            recLabel@5 in
                                      let
                                        @8 =
                                          Codec.Json.Unidirectional.Value.toBoolean
                                            v@6#0 in
                                      if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                                          (@7 @8#0)
                                      else if
                                        #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                                          (@8#0)
                                      else 
                                        #[prim.fail]()
                                    else 
                                      #[prim.fail]()
                              , "foo":
                                  \(lookupFn@4, recLabel@5) ->
                                    let v@6 = lookupFn@4 recLabel@5 in
                                    if
                                      #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Right
                                        (Data.Maybe.Nothing)
                                    else if
                                      #[prim.istag Data.Maybe.Just](v@6) thenlet
                                        @7 =
                                          Codec.Json.Unidirectional.Value.AtKey
                                            recLabel@5 in
                                      let
                                        @8 =
                                          Codec.Json.Unidirectional.Value.toBoolean
                                            v@6#0 in
                                      if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                                          (@7 @8#0)
                                      else if
                                        #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                                          (Data.Maybe.Just(@8#0))
                                      else 
                                        #[prim.fail]()
                                    else 
                                      #[prim.fail]()
                              } in
                        @4 in
                    \a@4 ->
                      let @5 = Codec.Json.Unidirectional.Value.toJObject a@4 in
                      if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                          (@5#0)
                      else if #[prim.istag Data.Either.Right](@5) then@3 @5#0
                      else 
                        #[prim.fail]() in
                \(lookupFn@4, recLabel@5) ->
                  let v@6 = lookupFn@4 recLabel@5 in
                  if #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Left
                      ( Codec.Json.Unidirectional.Value.AtKey
                        ( recLabel@5
                        , Codec.Json.Unidirectional.Value.DecodeError
                          ("Missing field")
                        )
                      )
                  else if #[prim.istag Data.Maybe.Just](v@6) thenlet
                      @7 = Codec.Json.Unidirectional.Value.AtKey recLabel@5 in
                    let @8 = @3 v@6#0 in
                    if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                        (@7 @8#0)
                    else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                        (@8#0)
                    else 
                      #[prim.fail]()
                  else 
                    #[prim.fail]()
            } in
      @2 in
  \a@2 ->
    let @3 = Codec.Json.Unidirectional.Value.toJObject a@2 in
    if #[prim.istag Data.Either.Left](@3) thenData.Either.Left(@3#0)
    else if #[prim.istag Data.Either.Right](@3) then@1 @3#0
    else 
      #[prim.fail]()

-- Snapshot.ToRecordInlines.decoder Step 5 -------------------------------------
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  {- Inline -}
  let @1 = \_ -> "nested" in
  let
    @2 =
      {- Inline -}
      let
        @2 =
          \v@2 codecs@3 j@4 ->
            let lbl@5 = @1 Type.Proxy.Proxy in
            let @6 = Record.Unsafe.unsafeGet (@1 Type.Proxy.Proxy) codecs@3 in
            let @7 = @0."toRecordObj" Type.Proxy.Proxy codecs@3 j@4 in
            if #[prim.istag Data.Either.Left](@7) thenlet
                v2@8 =
                  @6
                    ( \k@8 ->
                      Foreign.Object._lookup
                        (Data.Maybe.Nothing, Data.Maybe.Just, k@8, j@4)
                    , lbl@5
                    ) in
              if #[prim.istag Data.Either.Left](v2@8) thenData.Either.Left
                  ( if
                    #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                      (@7#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                      (Data.List.Types.Cons(v2@8#0, @7#0#0))
                  else 
                    Codec.Json.Unidirectional.Value.AccumulateError
                      ( Data.List.Types.Cons
                        ( v2@8#0
                        , Data.List.Types.Cons(@7#0, Data.List.Types.Nil)
                        )
                      )
                  )
              else 
                Data.Either.Left(@7#0)
            else if #[prim.istag Data.Either.Right](@7) then( if
                #[prim.istag Data.Either.Left](@7) thenlet @8 = @7#0 in
                \v@9 -> Data.Either.Left(@8)
              else if #[prim.istag Data.Either.Right](@7) thenlet @8 = @7#0 in
                \f@9 -> f@9 @8
              else 
                #[prim.fail]()
              )
                ( \rec@8 ->
                  let
                    @9 =
                      @6
                        ( \k@9 ->
                          Foreign.Object._lookup
                            (Data.Maybe.Nothing, Data.Maybe.Just, k@9, j@4)
                        , lbl@5
                        ) in
                  ( if #[prim.istag Data.Either.Left](@9) thenlet @10 = @9#0 in
                    \v@11 -> Data.Either.Left(@10)
                  else if #[prim.istag Data.Either.Right](@9) thenlet
                      @10 = @9#0 in
                    \f@11 -> f@11 @10
                  else 
                    #[prim.fail]()
                  )
                    ( \a@10 ->
                      Data.Either.Right
                        ( Record.Unsafe.unsafeSet
                          (@1 Type.Proxy.Proxy)
                          a@10
                          rec@8
                        )
                    )
                )
            else 
              #[prim.fail]() in
      @2
        Type.Proxy.Proxy
        { "req":
            \(lookupFn@3, recLabel@4) ->
              let v@5 = lookupFn@3 recLabel@4 in
              if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Left
                  ( Codec.Json.Unidirectional.Value.AtKey
                    ( recLabel@4
                    , Codec.Json.Unidirectional.Value.DecodeError
                      ("Missing field")
                    )
                  )
              else if #[prim.istag Data.Maybe.Just](v@5) thenlet
                  @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
                let @7 = Codec.Json.Unidirectional.Value.toInt v@5#0 in
                if #[prim.istag Data.Either.Left](@7) thenData.Either.Left
                    (@6 @7#0)
                else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                    (@7#0)
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]()
        , "reqRen":
            \(lookupFn@3, v@4) ->
              let v1@5 = lookupFn@3 "otherName" in
              if #[prim.istag Data.Maybe.Nothing](v1@5) thenData.Either.Left
                  ( Codec.Json.Unidirectional.Value.AtKey
                    ( "otherName"
                    , Codec.Json.Unidirectional.Value.DecodeError
                      ("Missing field")
                    )
                  )
              else if #[prim.istag Data.Maybe.Just](v1@5) thenlet
                  @6 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
                let @7 = Codec.Json.Unidirectional.Value.toString v1@5#0 in
                if #[prim.istag Data.Either.Left](@7) thenData.Either.Left
                    (@6 @7#0)
                else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                    (@7#0)
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]()
        , "opt":
            \(lookupFn@3, recLabel@4) ->
              let v@5 = lookupFn@3 recLabel@4 in
              if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Right
                  (Data.Maybe.Nothing)
              else if #[prim.istag Data.Maybe.Just](v@5) thenlet
                  @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
                let @7 = Codec.Json.Unidirectional.Value.toString v@5#0 in
                if #[prim.istag Data.Either.Left](@7) thenData.Either.Left
                    (@6 @7#0)
                else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                    (Data.Maybe.Just(@7#0))
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]()
        , "optRen":
            \(lookupFn@3, v@4) ->
              let v1@5 = lookupFn@3 "otherName2" in
              if #[prim.istag Data.Maybe.Nothing](v1@5) thenData.Either.Right
                  (Data.Maybe.Nothing)
              else if #[prim.istag Data.Maybe.Just](v1@5) thenlet
                  @6 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
                let @7 = Codec.Json.Unidirectional.Value.toString v1@5#0 in
                if #[prim.istag Data.Either.Left](@7) thenData.Either.Left
                    (@6 @7#0)
                else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                    (Data.Maybe.Just(@7#0))
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]()
        , "optArr":
            \(lookupFn@3, recLabel@4) ->
              let v@5 = lookupFn@3 recLabel@4 in
              if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Right([])
              else if #[prim.istag Data.Maybe.Just](v@5) thenlet
                  @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
                let
                  @7 =
                    Codec.Json.Unidirectional.Value.toArray
                      Codec.Json.Unidirectional.Value.toString
                      v@5#0 in
                if #[prim.istag Data.Either.Left](@7) thenData.Either.Left
                    (@6 @7#0)
                else if #[prim.istag Data.Either.Right](@7) thenData.Either.Right
                    (@7#0)
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]()
        , "nested":
            let
              @3 =
                Codec.Json.Unidirectional.Value.toRecordObjCons
                  Codec.Json.Unidirectional.Value.toRecordObjNil
                  { "reflectSymbol": \_ -> "other" }
                  #[prim.undefined]
                  #[prim.undefined]
                  #[prim.undefined] in
            {- Inline -}
            let @4 = \_ -> "foo" in
            let
              @5 =
                let
                  @5 =
                    {- Inline -}
                    let
                      @5 =
                        \v@5 codecs@6 j@7 ->
                          let lbl@8 = @4 Type.Proxy.Proxy in
                          let
                            @9 =
                              Record.Unsafe.unsafeGet
                                (@4 Type.Proxy.Proxy)
                                codecs@6 in
                          let
                            @10 = @3."toRecordObj" Type.Proxy.Proxy codecs@6 j@7 in
                          if #[prim.istag Data.Either.Left](@10) thenlet
                              v2@11 =
                                @9
                                  ( \k@11 ->
                                    Foreign.Object._lookup
                                      ( Data.Maybe.Nothing
                                      , Data.Maybe.Just
                                      , k@11
                                      , j@7
                                      )
                                  , lbl@8
                                  ) in
                            if #[prim.istag Data.Either.Left](v2@11) thenData.Either.Left
                                ( if
                                  #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                                    (@10#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                                    (Data.List.Types.Cons(v2@11#0, @10#0#0))
                                else 
                                  Codec.Json.Unidirectional.Value.AccumulateError
                                    ( Data.List.Types.Cons
                                      ( v2@11#0
                                      , Data.List.Types.Cons
                                        (@10#0, Data.List.Types.Nil)
                                      )
                                    )
                                )
                            else 
                              Data.Either.Left(@10#0)
                          else if #[prim.istag Data.Either.Right](@10) then( if
                              #[prim.istag Data.Either.Left](@10) thenlet
                                @11 = @10#0 in
                              \v@12 -> Data.Either.Left(@11)
                            else if #[prim.istag Data.Either.Right](@10) thenlet
                                @11 = @10#0 in
                              \f@12 -> f@12 @11
                            else 
                              #[prim.fail]()
                            )
                              ( \rec@11 ->
                                let
                                  @12 =
                                    @9
                                      ( \k@12 ->
                                        Foreign.Object._lookup
                                          ( Data.Maybe.Nothing
                                          , Data.Maybe.Just
                                          , k@12
                                          , j@7
                                          )
                                      , lbl@8
                                      ) in
                                ( if #[prim.istag Data.Either.Left](@12) thenlet
                                    @13 = @12#0 in
                                  \v@14 -> Data.Either.Left(@13)
                                else if
                                  #[prim.istag Data.Either.Right](@12) thenlet
                                    @13 = @12#0 in
                                  \f@14 -> f@14 @13
                                else 
                                  #[prim.fail]()
                                )
                                  ( \a@13 ->
                                    Data.Either.Right
                                      ( Record.Unsafe.unsafeSet
                                        (@4 Type.Proxy.Proxy)
                                        a@13
                                        rec@11
                                      )
                                  )
                              )
                          else 
                            #[prim.fail]() in
                    @5
                      Type.Proxy.Proxy
                      { "other":
                          \(lookupFn@6, recLabel@7) ->
                            let v@8 = lookupFn@6 recLabel@7 in
                            if #[prim.istag Data.Maybe.Nothing](v@8) thenData.Either.Left
                                ( Codec.Json.Unidirectional.Value.AtKey
                                  ( recLabel@7
                                  , Codec.Json.Unidirectional.Value.DecodeError
                                    ("Missing field")
                                  )
                                )
                            else if #[prim.istag Data.Maybe.Just](v@8) thenlet
                                @9 =
                                  Codec.Json.Unidirectional.Value.AtKey
                                    recLabel@7 in
                              let
                                @10 =
                                  Codec.Json.Unidirectional.Value.toBoolean
                                    v@8#0 in
                              if #[prim.istag Data.Either.Left](@10) thenData.Either.Left
                                  (@9 @10#0)
                              else if #[prim.istag Data.Either.Right](@10) thenData.Either.Right
                                  (@10#0)
                              else 
                                #[prim.fail]()
                            else 
                              #[prim.fail]()
                      , "foo":
                          \(lookupFn@6, recLabel@7) ->
                            let v@8 = lookupFn@6 recLabel@7 in
                            if #[prim.istag Data.Maybe.Nothing](v@8) thenData.Either.Right
                                (Data.Maybe.Nothing)
                            else if #[prim.istag Data.Maybe.Just](v@8) thenlet
                                @9 =
                                  Codec.Json.Unidirectional.Value.AtKey
                                    recLabel@7 in
                              let
                                @10 =
                                  Codec.Json.Unidirectional.Value.toBoolean
                                    v@8#0 in
                              if #[prim.istag Data.Either.Left](@10) thenData.Either.Left
                                  (@9 @10#0)
                              else if #[prim.istag Data.Either.Right](@10) thenData.Either.Right
                                  (Data.Maybe.Just(@10#0))
                              else 
                                #[prim.fail]()
                            else 
                              #[prim.fail]()
                      } in
                \a@6 ->
                  let @7 = Codec.Json.Unidirectional.Value.toJObject a@6 in
                  if #[prim.istag Data.Either.Left](@7) thenData.Either.Left
                      (@7#0)
                  else if #[prim.istag Data.Either.Right](@7) then@5 @7#0
                  else 
                    #[prim.fail]() in
            \(lookupFn@6, recLabel@7) ->
              let v@8 = lookupFn@6 recLabel@7 in
              if #[prim.istag Data.Maybe.Nothing](v@8) thenData.Either.Left
                  ( Codec.Json.Unidirectional.Value.AtKey
                    ( recLabel@7
                    , Codec.Json.Unidirectional.Value.DecodeError
                      ("Missing field")
                    )
                  )
              else if #[prim.istag Data.Maybe.Just](v@8) thenlet
                  @9 = Codec.Json.Unidirectional.Value.AtKey recLabel@7 in
                let @10 = @5 v@8#0 in
                if #[prim.istag Data.Either.Left](@10) thenData.Either.Left
                    (@9 @10#0)
                else if #[prim.istag Data.Either.Right](@10) thenData.Either.Right
                    (@10#0)
                else 
                  #[prim.fail]()
              else 
                #[prim.fail]()
        } in
  \a@3 ->
    let @4 = Codec.Json.Unidirectional.Value.toJObject a@3 in
    if #[prim.istag Data.Either.Left](@4) thenData.Either.Left(@4#0)
    else if #[prim.istag Data.Either.Right](@4) then@2 @4#0
    else 
      #[prim.fail]()

-- Snapshot.ToRecordInlines.decoder Step 6 -------------------------------------
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  {- Inline -}
  let @1 = Type.Proxy.Proxy in
  let
    @2 =
      let
        @2 =
          { "req":
              \(lookupFn@2, recLabel@3) ->
                let v@4 = lookupFn@2 recLabel@3 in
                if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Left
                    ( Codec.Json.Unidirectional.Value.AtKey
                      ( recLabel@3
                      , Codec.Json.Unidirectional.Value.DecodeError
                        ("Missing field")
                      )
                    )
                else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                    @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                  let @6 = Codec.Json.Unidirectional.Value.toInt v@4#0 in
                  if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                      (@5 @6#0)
                  else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                      (@6#0)
                  else 
                    #[prim.fail]()
                else 
                  #[prim.fail]()
          , "reqRen":
              \(lookupFn@2, v@3) ->
                let v1@4 = lookupFn@2 "otherName" in
                if #[prim.istag Data.Maybe.Nothing](v1@4) thenData.Either.Left
                    ( Codec.Json.Unidirectional.Value.AtKey
                      ( "otherName"
                      , Codec.Json.Unidirectional.Value.DecodeError
                        ("Missing field")
                      )
                    )
                else if #[prim.istag Data.Maybe.Just](v1@4) thenlet
                    @5 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
                  let @6 = Codec.Json.Unidirectional.Value.toString v1@4#0 in
                  if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                      (@5 @6#0)
                  else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                      (@6#0)
                  else 
                    #[prim.fail]()
                else 
                  #[prim.fail]()
          , "opt":
              \(lookupFn@2, recLabel@3) ->
                let v@4 = lookupFn@2 recLabel@3 in
                if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                    (Data.Maybe.Nothing)
                else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                    @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                  let @6 = Codec.Json.Unidirectional.Value.toString v@4#0 in
                  if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                      (@5 @6#0)
                  else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                      (Data.Maybe.Just(@6#0))
                  else 
                    #[prim.fail]()
                else 
                  #[prim.fail]()
          , "optRen":
              \(lookupFn@2, v@3) ->
                let v1@4 = lookupFn@2 "otherName2" in
                if #[prim.istag Data.Maybe.Nothing](v1@4) thenData.Either.Right
                    (Data.Maybe.Nothing)
                else if #[prim.istag Data.Maybe.Just](v1@4) thenlet
                    @5 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
                  let @6 = Codec.Json.Unidirectional.Value.toString v1@4#0 in
                  if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                      (@5 @6#0)
                  else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                      (Data.Maybe.Just(@6#0))
                  else 
                    #[prim.fail]()
                else 
                  #[prim.fail]()
          , "optArr":
              \(lookupFn@2, recLabel@3) ->
                let v@4 = lookupFn@2 recLabel@3 in
                if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                    ([])
                else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                    @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                  let
                    @6 =
                      Codec.Json.Unidirectional.Value.toArray
                        Codec.Json.Unidirectional.Value.toString
                        v@4#0 in
                  if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                      (@5 @6#0)
                  else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                      (@6#0)
                  else 
                    #[prim.fail]()
                else 
                  #[prim.fail]()
          , "nested":
              let
                @2 =
                  Codec.Json.Unidirectional.Value.toRecordObjCons
                    Codec.Json.Unidirectional.Value.toRecordObjNil
                    { "reflectSymbol": \_ -> "other" }
                    #[prim.undefined]
                    #[prim.undefined]
                    #[prim.undefined] in
              {- Inline -}
              let @3 = Type.Proxy.Proxy in
              let
                @4 =
                  let
                    @4 =
                      let
                        @4 =
                          { "other":
                              \(lookupFn@4, recLabel@5) ->
                                let v@6 = lookupFn@4 recLabel@5 in
                                if #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Left
                                    ( Codec.Json.Unidirectional.Value.AtKey
                                      ( recLabel@5
                                      , Codec.Json.Unidirectional.Value.DecodeError
                                        ("Missing field")
                                      )
                                    )
                                else if #[prim.istag Data.Maybe.Just](v@6) thenlet
                                    @7 =
                                      Codec.Json.Unidirectional.Value.AtKey
                                        recLabel@5 in
                                  let
                                    @8 =
                                      Codec.Json.Unidirectional.Value.toBoolean
                                        v@6#0 in
                                  if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                                      (@7 @8#0)
                                  else if
                                    #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                                      (@8#0)
                                  else 
                                    #[prim.fail]()
                                else 
                                  #[prim.fail]()
                          , "foo":
                              \(lookupFn@4, recLabel@5) ->
                                let v@6 = lookupFn@4 recLabel@5 in
                                if #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Right
                                    (Data.Maybe.Nothing)
                                else if #[prim.istag Data.Maybe.Just](v@6) thenlet
                                    @7 =
                                      Codec.Json.Unidirectional.Value.AtKey
                                        recLabel@5 in
                                  let
                                    @8 =
                                      Codec.Json.Unidirectional.Value.toBoolean
                                        v@6#0 in
                                  if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                                      (@7 @8#0)
                                  else if
                                    #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                                      (Data.Maybe.Just(@8#0))
                                  else 
                                    #[prim.fail]()
                                else 
                                  #[prim.fail]()
                          } in
                      \j@5 ->
                        {- Inline -}
                        let @6 = Type.Proxy.Proxy in
                        {- Inline -}
                        let lbl@7 = "foo" in
                        let
                          @8 =
                            Record.Unsafe.unsafeGet
                              ( {- Inline -}
                              let @8 = Type.Proxy.Proxy in
                              "foo"
                              )
                              @4 in
                        let @9 = @2."toRecordObj" Type.Proxy.Proxy @4 j@5 in
                        if #[prim.istag Data.Either.Left](@9) thenlet
                            v2@10 =
                              @8
                                ( \k@10 ->
                                  Foreign.Object._lookup
                                    ( Data.Maybe.Nothing
                                    , Data.Maybe.Just
                                    , k@10
                                    , j@5
                                    )
                                , lbl@7
                                ) in
                          if #[prim.istag Data.Either.Left](v2@10) thenData.Either.Left
                              ( if
                                #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                                  (@9#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                                  (Data.List.Types.Cons(v2@10#0, @9#0#0))
                              else 
                                Codec.Json.Unidirectional.Value.AccumulateError
                                  ( Data.List.Types.Cons
                                    ( v2@10#0
                                    , Data.List.Types.Cons
                                      (@9#0, Data.List.Types.Nil)
                                    )
                                  )
                              )
                          else 
                            Data.Either.Left(@9#0)
                        else if #[prim.istag Data.Either.Right](@9) then( if
                            #[prim.istag Data.Either.Left](@9) thenlet
                              @10 = @9#0 in
                            \v@11 -> Data.Either.Left(@10)
                          else if #[prim.istag Data.Either.Right](@9) thenlet
                              @10 = @9#0 in
                            \f@11 -> f@11 @10
                          else 
                            #[prim.fail]()
                          )
                            ( \rec@10 ->
                              let
                                @11 =
                                  @8
                                    ( \k@11 ->
                                      Foreign.Object._lookup
                                        ( Data.Maybe.Nothing
                                        , Data.Maybe.Just
                                        , k@11
                                        , j@5
                                        )
                                    , lbl@7
                                    ) in
                              ( if #[prim.istag Data.Either.Left](@11) thenlet
                                  @12 = @11#0 in
                                \v@13 -> Data.Either.Left(@12)
                              else if #[prim.istag Data.Either.Right](@11) thenlet
                                  @12 = @11#0 in
                                \f@13 -> f@13 @12
                              else 
                                #[prim.fail]()
                              )
                                ( \a@12 ->
                                  Data.Either.Right
                                    ( Record.Unsafe.unsafeSet
                                      ( {- Inline -}
                                      let @13 = Type.Proxy.Proxy in
                                      "foo"
                                      )
                                      a@12
                                      rec@10
                                    )
                                )
                            )
                        else 
                          #[prim.fail]() in
                  \a@5 ->
                    let @6 = Codec.Json.Unidirectional.Value.toJObject a@5 in
                    if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                        (@6#0)
                    else if #[prim.istag Data.Either.Right](@6) then@4 @6#0
                    else 
                      #[prim.fail]() in
              \(lookupFn@5, recLabel@6) ->
                let v@7 = lookupFn@5 recLabel@6 in
                if #[prim.istag Data.Maybe.Nothing](v@7) thenData.Either.Left
                    ( Codec.Json.Unidirectional.Value.AtKey
                      ( recLabel@6
                      , Codec.Json.Unidirectional.Value.DecodeError
                        ("Missing field")
                      )
                    )
                else if #[prim.istag Data.Maybe.Just](v@7) thenlet
                    @8 = Codec.Json.Unidirectional.Value.AtKey recLabel@6 in
                  let @9 = @4 v@7#0 in
                  if #[prim.istag Data.Either.Left](@9) thenData.Either.Left
                      (@8 @9#0)
                  else if #[prim.istag Data.Either.Right](@9) thenData.Either.Right
                      (@9#0)
                  else 
                    #[prim.fail]()
                else 
                  #[prim.fail]()
          } in
      \j@3 ->
        {- Inline -}
        let @4 = Type.Proxy.Proxy in
        {- Inline -}
        let lbl@5 = "nested" in
        let
          @6 =
            Record.Unsafe.unsafeGet
              ( {- Inline -}
              let @6 = Type.Proxy.Proxy in
              "nested"
              )
              @2 in
        let @7 = @0."toRecordObj" Type.Proxy.Proxy @2 j@3 in
        if #[prim.istag Data.Either.Left](@7) thenlet
            v2@8 =
              @6
                ( \k@8 ->
                  Foreign.Object._lookup
                    (Data.Maybe.Nothing, Data.Maybe.Just, k@8, j@3)
                , lbl@5
                ) in
          if #[prim.istag Data.Either.Left](v2@8) thenData.Either.Left
              ( if
                #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                  (@7#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                  (Data.List.Types.Cons(v2@8#0, @7#0#0))
              else 
                Codec.Json.Unidirectional.Value.AccumulateError
                  ( Data.List.Types.Cons
                    (v2@8#0, Data.List.Types.Cons(@7#0, Data.List.Types.Nil))
                  )
              )
          else 
            Data.Either.Left(@7#0)
        else if #[prim.istag Data.Either.Right](@7) then( if
            #[prim.istag Data.Either.Left](@7) thenlet @8 = @7#0 in
            \v@9 -> Data.Either.Left(@8)
          else if #[prim.istag Data.Either.Right](@7) thenlet @8 = @7#0 in
            \f@9 -> f@9 @8
          else 
            #[prim.fail]()
          )
            ( \rec@8 ->
              let
                @9 =
                  @6
                    ( \k@9 ->
                      Foreign.Object._lookup
                        (Data.Maybe.Nothing, Data.Maybe.Just, k@9, j@3)
                    , lbl@5
                    ) in
              ( if #[prim.istag Data.Either.Left](@9) thenlet @10 = @9#0 in
                \v@11 -> Data.Either.Left(@10)
              else if #[prim.istag Data.Either.Right](@9) thenlet @10 = @9#0 in
                \f@11 -> f@11 @10
              else 
                #[prim.fail]()
              )
                ( \a@10 ->
                  Data.Either.Right
                    ( Record.Unsafe.unsafeSet
                      ( {- Inline -}
                      let @11 = Type.Proxy.Proxy in
                      "nested"
                      )
                      a@10
                      rec@8
                    )
                )
            )
        else 
          #[prim.fail]() in
  \a@3 ->
    let @4 = Codec.Json.Unidirectional.Value.toJObject a@3 in
    if #[prim.istag Data.Either.Left](@4) thenData.Either.Left(@4#0)
    else if #[prim.istag Data.Either.Right](@4) then@2 @4#0
    else 
      #[prim.fail]()

-- Snapshot.ToRecordInlines.decoder Step 7 -------------------------------------
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  let
    @1 =
      { "req":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@2
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toInt v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "reqRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( "otherName"
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "opt":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toString v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName2" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optArr":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right([])
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let
                @5 =
                  Codec.Json.Unidirectional.Value.toArray
                    Codec.Json.Unidirectional.Value.toString
                    v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "nested":
          let
            @1 =
              Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "other" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined] in
          let
            @2 =
              { "other":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Left
                        ( Codec.Json.Unidirectional.Value.AtKey
                          ( recLabel@3
                          , Codec.Json.Unidirectional.Value.DecodeError
                            ("Missing field")
                          )
                        )
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (@6#0)
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              , "foo":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                        (Data.Maybe.Nothing)
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (Data.Maybe.Just(@6#0))
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              } in
          let
            @3 =
              {- Inline -}
              let
                @3 =
                  \j@3 ->
                    {- Inline -}
                    let @4 = @2."foo" in
                    let @5 = @1."toRecordObj" Type.Proxy.Proxy @2 j@3 in
                    if #[prim.istag Data.Either.Left](@5) thenlet
                        v2@6 =
                          @4
                            ( \k@6 ->
                              Foreign.Object._lookup
                                (Data.Maybe.Nothing, Data.Maybe.Just, k@6, j@3)
                            , "foo"
                            ) in
                      if #[prim.istag Data.Either.Left](v2@6) thenData.Either.Left
                          ( if
                            #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                              (@5#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                              (Data.List.Types.Cons(v2@6#0, @5#0#0))
                          else 
                            Codec.Json.Unidirectional.Value.AccumulateError
                              ( Data.List.Types.Cons
                                ( v2@6#0
                                , Data.List.Types.Cons
                                  (@5#0, Data.List.Types.Nil)
                                )
                              )
                          )
                      else 
                        Data.Either.Left(@5#0)
                    else if #[prim.istag Data.Either.Right](@5) then( if
                        #[prim.istag Data.Either.Left](@5) thenlet @6 = @5#0 in
                        \v@7 -> Data.Either.Left(@6)
                      else if #[prim.istag Data.Either.Right](@5) thenlet
                          @6 = @5#0 in
                        \f@7 -> f@7 @6
                      else 
                        #[prim.fail]()
                      )
                        ( \rec@6 ->
                          let
                            @7 =
                              @4
                                ( \k@7 ->
                                  Foreign.Object._lookup
                                    ( Data.Maybe.Nothing
                                    , Data.Maybe.Just
                                    , k@7
                                    , j@3
                                    )
                                , "foo"
                                ) in
                          ( if #[prim.istag Data.Either.Left](@7) thenlet
                              @8 = @7#0 in
                            \v@9 -> Data.Either.Left(@8)
                          else if #[prim.istag Data.Either.Right](@7) thenlet
                              @8 = @7#0 in
                            \f@9 -> f@9 @8
                          else 
                            #[prim.fail]()
                          )
                            (\a@8 -> Data.Either.Right(rec@6 { "foo" = a@8 }))
                        )
                    else 
                      #[prim.fail]() in
              \a@4 ->
                let @5 = Codec.Json.Unidirectional.Value.toJObject a@4 in
                if #[prim.istag Data.Either.Left](@5) thenData.Either.Left(@5#0)
                else if #[prim.istag Data.Either.Right](@5) then@3 @5#0
                else 
                  #[prim.fail]() in
          \(lookupFn@4, recLabel@5) ->
            let v@6 = lookupFn@4 recLabel@5 in
            if #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@5
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@6) thenlet
                @7 = Codec.Json.Unidirectional.Value.AtKey recLabel@5 in
              let @8 = @3 v@6#0 in
              if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                  (@7 @8#0)
              else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                  (@8#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      } in
  {- Inline -}
  let
    @2 =
      \j@2 ->
        {- Inline -}
        let @3 = @1."nested" in
        let @4 = @0."toRecordObj" Type.Proxy.Proxy @1 j@2 in
        if #[prim.istag Data.Either.Left](@4) thenlet
            v2@5 =
              @3
                ( \k@5 ->
                  Foreign.Object._lookup
                    (Data.Maybe.Nothing, Data.Maybe.Just, k@5, j@2)
                , "nested"
                ) in
          if #[prim.istag Data.Either.Left](v2@5) thenData.Either.Left
              ( if
                #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                  (@4#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                  (Data.List.Types.Cons(v2@5#0, @4#0#0))
              else 
                Codec.Json.Unidirectional.Value.AccumulateError
                  ( Data.List.Types.Cons
                    (v2@5#0, Data.List.Types.Cons(@4#0, Data.List.Types.Nil))
                  )
              )
          else 
            Data.Either.Left(@4#0)
        else if #[prim.istag Data.Either.Right](@4) then( if
            #[prim.istag Data.Either.Left](@4) thenlet @5 = @4#0 in
            \v@6 -> Data.Either.Left(@5)
          else if #[prim.istag Data.Either.Right](@4) thenlet @5 = @4#0 in
            \f@6 -> f@6 @5
          else 
            #[prim.fail]()
          )
            ( \rec@5 ->
              let
                @6 =
                  @3
                    ( \k@6 ->
                      Foreign.Object._lookup
                        (Data.Maybe.Nothing, Data.Maybe.Just, k@6, j@2)
                    , "nested"
                    ) in
              ( if #[prim.istag Data.Either.Left](@6) thenlet @7 = @6#0 in
                \v@8 -> Data.Either.Left(@7)
              else if #[prim.istag Data.Either.Right](@6) thenlet @7 = @6#0 in
                \f@8 -> f@8 @7
              else 
                #[prim.fail]()
              )
                (\a@7 -> Data.Either.Right(rec@5 { "nested" = a@7 }))
            )
        else 
          #[prim.fail]() in
  \a@3 ->
    let @4 = Codec.Json.Unidirectional.Value.toJObject a@3 in
    if #[prim.istag Data.Either.Left](@4) thenData.Either.Left(@4#0)
    else if #[prim.istag Data.Either.Right](@4) then@2 @4#0
    else 
      #[prim.fail]()

-- Snapshot.ToRecordInlines.decoder Step 8 -------------------------------------
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  let
    @1 =
      { "req":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@2
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toInt v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "reqRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( "otherName"
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "opt":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toString v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName2" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optArr":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right([])
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let
                @5 =
                  Codec.Json.Unidirectional.Value.toArray
                    Codec.Json.Unidirectional.Value.toString
                    v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "nested":
          let
            @1 =
              Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "other" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined] in
          let
            @2 =
              { "other":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Left
                        ( Codec.Json.Unidirectional.Value.AtKey
                          ( recLabel@3
                          , Codec.Json.Unidirectional.Value.DecodeError
                            ("Missing field")
                          )
                        )
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (@6#0)
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              , "foo":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                        (Data.Maybe.Nothing)
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (Data.Maybe.Just(@6#0))
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              } in
          {- Inline -}
          let
            @3 =
              \a@3 ->
                let @4 = Codec.Json.Unidirectional.Value.toJObject a@3 in
                if #[prim.istag Data.Either.Left](@4) thenData.Either.Left(@4#0)
                else if #[prim.istag Data.Either.Right](@4) then{- Inline -}
                  let @5 = @4#0 in
                  let @6 = @1."toRecordObj" Type.Proxy.Proxy @2 @5 in
                  {- Inline -}
                  let
                    @7 =
                      if #[prim.istag Data.Either.Left](@6) thenlet
                          v2@7 =
                            @2."foo"
                              ( \k@7 ->
                                Foreign.Object._lookup
                                  (Data.Maybe.Nothing, Data.Maybe.Just, k@7, @5)
                              , "foo"
                              ) in
                        if #[prim.istag Data.Either.Left](v2@7) thenData.Either.Left
                            ( if
                              #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                                (@6#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                                (Data.List.Types.Cons(v2@7#0, @6#0#0))
                            else 
                              Codec.Json.Unidirectional.Value.AccumulateError
                                ( Data.List.Types.Cons
                                  ( v2@7#0
                                  , Data.List.Types.Cons
                                    (@6#0, Data.List.Types.Nil)
                                  )
                                )
                            )
                        else 
                          Data.Either.Left(@6#0)
                      else if #[prim.istag Data.Either.Right](@6) then( if
                          #[prim.istag Data.Either.Left](@6) thenlet
                            @7 = @6#0 in
                          \v@8 -> Data.Either.Left(@7)
                        else if #[prim.istag Data.Either.Right](@6) thenlet
                            @7 = @6#0 in
                          \f@8 -> f@8 @7
                        else 
                          #[prim.fail]()
                        )
                          ( \rec@7 ->
                            let
                              @8 =
                                @2."foo"
                                  ( \k@8 ->
                                    Foreign.Object._lookup
                                      ( Data.Maybe.Nothing
                                      , Data.Maybe.Just
                                      , k@8
                                      , @5
                                      )
                                  , "foo"
                                  ) in
                            ( if #[prim.istag Data.Either.Left](@8) thenlet
                                @9 = @8#0 in
                              \v@10 -> Data.Either.Left(@9)
                            else if #[prim.istag Data.Either.Right](@8) thenlet
                                @9 = @8#0 in
                              \f@10 -> f@10 @9
                            else 
                              #[prim.fail]()
                            )
                              (\a@9 -> Data.Either.Right(rec@7 { "foo" = a@9 }))
                          )
                      else 
                        #[prim.fail]() in
                  @7
                else 
                  #[prim.fail]() in
          \(lookupFn@4, recLabel@5) ->
            let v@6 = lookupFn@4 recLabel@5 in
            if #[prim.istag Data.Maybe.Nothing](v@6) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@5
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@6) thenlet
                @7 = Codec.Json.Unidirectional.Value.AtKey recLabel@5 in
              let @8 = @3 v@6#0 in
              if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                  (@7 @8#0)
              else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                  (@8#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      } in
  \a@2 ->
    let @3 = Codec.Json.Unidirectional.Value.toJObject a@2 in
    if #[prim.istag Data.Either.Left](@3) thenData.Either.Left(@3#0)
    else if #[prim.istag Data.Either.Right](@3) then{- Inline -}
      let @4 = @3#0 in
      let @5 = @0."toRecordObj" Type.Proxy.Proxy @1 @4 in
      {- Inline -}
      let
        @6 =
          if #[prim.istag Data.Either.Left](@5) thenlet
              v2@6 =
                @1."nested"
                  ( \k@6 ->
                    Foreign.Object._lookup
                      (Data.Maybe.Nothing, Data.Maybe.Just, k@6, @4)
                  , "nested"
                  ) in
            if #[prim.istag Data.Either.Left](v2@6) thenData.Either.Left
                ( if
                  #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                    (@5#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                    (Data.List.Types.Cons(v2@6#0, @5#0#0))
                else 
                  Codec.Json.Unidirectional.Value.AccumulateError
                    ( Data.List.Types.Cons
                      (v2@6#0, Data.List.Types.Cons(@5#0, Data.List.Types.Nil))
                    )
                )
            else 
              Data.Either.Left(@5#0)
          else if #[prim.istag Data.Either.Right](@5) then( if
              #[prim.istag Data.Either.Left](@5) thenlet @6 = @5#0 in
              \v@7 -> Data.Either.Left(@6)
            else if #[prim.istag Data.Either.Right](@5) thenlet @6 = @5#0 in
              \f@7 -> f@7 @6
            else 
              #[prim.fail]()
            )
              ( \rec@6 ->
                let
                  @7 =
                    @1."nested"
                      ( \k@7 ->
                        Foreign.Object._lookup
                          (Data.Maybe.Nothing, Data.Maybe.Just, k@7, @4)
                      , "nested"
                      ) in
                ( if #[prim.istag Data.Either.Left](@7) thenlet @8 = @7#0 in
                  \v@9 -> Data.Either.Left(@8)
                else if #[prim.istag Data.Either.Right](@7) thenlet @8 = @7#0 in
                  \f@9 -> f@9 @8
                else 
                  #[prim.fail]()
                )
                  (\a@8 -> Data.Either.Right(rec@6 { "nested" = a@8 }))
              )
          else 
            #[prim.fail]() in
      @6
    else 
      #[prim.fail]()

-- Snapshot.ToRecordInlines.decoder Step 9 -------------------------------------
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  let
    @1 =
      { "req":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@2
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toInt v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "reqRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( "otherName"
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "opt":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toString v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName2" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optArr":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right([])
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let
                @5 =
                  Codec.Json.Unidirectional.Value.toArray
                    Codec.Json.Unidirectional.Value.toString
                    v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "nested":
          let
            @1 =
              Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "other" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined] in
          let
            @2 =
              { "other":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Left
                        ( Codec.Json.Unidirectional.Value.AtKey
                          ( recLabel@3
                          , Codec.Json.Unidirectional.Value.DecodeError
                            ("Missing field")
                          )
                        )
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (@6#0)
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              , "foo":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                        (Data.Maybe.Nothing)
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (Data.Maybe.Just(@6#0))
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              } in
          \(lookupFn@3, recLabel@4) ->
            let v@5 = lookupFn@3 recLabel@4 in
            if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@4
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@5) thenlet
                @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
              {- Inline -}
              let @7 = v@5#0 in
              let
                @8 =
                  let @8 = Codec.Json.Unidirectional.Value.toJObject @7 in
                  {- Inline -}
                  let
                    @9 =
                      if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                          (@8#0)
                      else if #[prim.istag Data.Either.Right](@8) thenlet
                          @9 = @1."toRecordObj" Type.Proxy.Proxy @2 @8#0 in
                        if #[prim.istag Data.Either.Left](@9) thenlet
                            v2@10 =
                              @2."foo"
                                ( \k@10 ->
                                  Foreign.Object._lookup
                                    ( Data.Maybe.Nothing
                                    , Data.Maybe.Just
                                    , k@10
                                    , @8#0
                                    )
                                , "foo"
                                ) in
                          if #[prim.istag Data.Either.Left](v2@10) thenData.Either.Left
                              ( if
                                #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                                  (@9#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                                  (Data.List.Types.Cons(v2@10#0, @9#0#0))
                              else 
                                Codec.Json.Unidirectional.Value.AccumulateError
                                  ( Data.List.Types.Cons
                                    ( v2@10#0
                                    , Data.List.Types.Cons
                                      (@9#0, Data.List.Types.Nil)
                                    )
                                  )
                              )
                          else 
                            Data.Either.Left(@9#0)
                        else if #[prim.istag Data.Either.Right](@9) then( if
                            #[prim.istag Data.Either.Left](@9) thenlet
                              @10 = @9#0 in
                            \v@11 -> Data.Either.Left(@10)
                          else if #[prim.istag Data.Either.Right](@9) thenlet
                              @10 = @9#0 in
                            \f@11 -> f@11 @10
                          else 
                            #[prim.fail]()
                          )
                            ( \rec@10 ->
                              let
                                @11 =
                                  @2."foo"
                                    ( \k@11 ->
                                      Foreign.Object._lookup
                                        ( Data.Maybe.Nothing
                                        , Data.Maybe.Just
                                        , k@11
                                        , @8#0
                                        )
                                    , "foo"
                                    ) in
                              ( if #[prim.istag Data.Either.Left](@11) thenlet
                                  @12 = @11#0 in
                                \v@13 -> Data.Either.Left(@12)
                              else if #[prim.istag Data.Either.Right](@11) thenlet
                                  @12 = @11#0 in
                                \f@13 -> f@13 @12
                              else 
                                #[prim.fail]()
                              )
                                ( \a@12 ->
                                  Data.Either.Right(rec@10 { "foo" = a@12 })
                                )
                            )
                        else 
                          #[prim.fail]()
                      else 
                        #[prim.fail]() in
                  @9 in
              if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                  (@6 @8#0)
              else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                  (@8#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      } in
  \a@2 ->
    let @3 = Codec.Json.Unidirectional.Value.toJObject a@2 in
    if #[prim.istag Data.Either.Left](@3) thenData.Either.Left(@3#0)
    else if #[prim.istag Data.Either.Right](@3) thenlet
        @4 = @0."toRecordObj" Type.Proxy.Proxy @1 @3#0 in
      if #[prim.istag Data.Either.Left](@4) thenlet
          v2@5 =
            @1."nested"
              ( \k@5 ->
                Foreign.Object._lookup
                  (Data.Maybe.Nothing, Data.Maybe.Just, k@5, @3#0)
              , "nested"
              ) in
        if #[prim.istag Data.Either.Left](v2@5) thenData.Either.Left
            ( if
              #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                (@4#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                (Data.List.Types.Cons(v2@5#0, @4#0#0))
            else 
              Codec.Json.Unidirectional.Value.AccumulateError
                ( Data.List.Types.Cons
                  (v2@5#0, Data.List.Types.Cons(@4#0, Data.List.Types.Nil))
                )
            )
        else 
          Data.Either.Left(@4#0)
      else if #[prim.istag Data.Either.Right](@4) then( if
          #[prim.istag Data.Either.Left](@4) thenlet @5 = @4#0 in
          \v@6 -> Data.Either.Left(@5)
        else if #[prim.istag Data.Either.Right](@4) thenlet @5 = @4#0 in
          \f@6 -> f@6 @5
        else 
          #[prim.fail]()
        )
          ( \rec@5 ->
            let
              @6 =
                @1."nested"
                  ( \k@6 ->
                    Foreign.Object._lookup
                      (Data.Maybe.Nothing, Data.Maybe.Just, k@6, @3#0)
                  , "nested"
                  ) in
            ( if #[prim.istag Data.Either.Left](@6) thenlet @7 = @6#0 in
              \v@8 -> Data.Either.Left(@7)
            else if #[prim.istag Data.Either.Right](@6) thenlet @7 = @6#0 in
              \f@8 -> f@8 @7
            else 
              #[prim.fail]()
            )
              (\a@7 -> Data.Either.Right(rec@5 { "nested" = a@7 }))
          )
      else 
        #[prim.fail]()
    else 
      #[prim.fail]()

-- Snapshot.ToRecordInlines.decoder Step 10 (Final) ----------------------------
  let
    @0 =
      Codec.Json.Unidirectional.Value.toRecordObjCons
        ( Codec.Json.Unidirectional.Value.toRecordObjCons
          ( Codec.Json.Unidirectional.Value.toRecordObjCons
            ( Codec.Json.Unidirectional.Value.toRecordObjCons
              ( Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "reqRen" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined]
              )
              { "reflectSymbol": \_ -> "req" }
              #[prim.undefined]
              #[prim.undefined]
              #[prim.undefined]
            )
            { "reflectSymbol": \_ -> "optRen" }
            #[prim.undefined]
            #[prim.undefined]
            #[prim.undefined]
          )
          { "reflectSymbol": \_ -> "optArr" }
          #[prim.undefined]
          #[prim.undefined]
          #[prim.undefined]
        )
        { "reflectSymbol": \_ -> "opt" }
        #[prim.undefined]
        #[prim.undefined]
        #[prim.undefined] in
  let
    @1 =
      { "req":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@2
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toInt v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "reqRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( "otherName"
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "opt":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let @5 = Codec.Json.Unidirectional.Value.toString v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optRen":
          \(lookupFn@1, v@2) ->
            let v1@3 = lookupFn@1 "otherName2" in
            if #[prim.istag Data.Maybe.Nothing](v1@3) thenData.Either.Right
                (Data.Maybe.Nothing)
            else if #[prim.istag Data.Maybe.Just](v1@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey "otherName2" in
              let @5 = Codec.Json.Unidirectional.Value.toString v1@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (Data.Maybe.Just(@5#0))
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "optArr":
          \(lookupFn@1, recLabel@2) ->
            let v@3 = lookupFn@1 recLabel@2 in
            if #[prim.istag Data.Maybe.Nothing](v@3) thenData.Either.Right([])
            else if #[prim.istag Data.Maybe.Just](v@3) thenlet
                @4 = Codec.Json.Unidirectional.Value.AtKey recLabel@2 in
              let
                @5 =
                  Codec.Json.Unidirectional.Value.toArray
                    Codec.Json.Unidirectional.Value.toString
                    v@3#0 in
              if #[prim.istag Data.Either.Left](@5) thenData.Either.Left
                  (@4 @5#0)
              else if #[prim.istag Data.Either.Right](@5) thenData.Either.Right
                  (@5#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      , "nested":
          let
            @1 =
              Codec.Json.Unidirectional.Value.toRecordObjCons
                Codec.Json.Unidirectional.Value.toRecordObjNil
                { "reflectSymbol": \_ -> "other" }
                #[prim.undefined]
                #[prim.undefined]
                #[prim.undefined] in
          let
            @2 =
              { "other":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Left
                        ( Codec.Json.Unidirectional.Value.AtKey
                          ( recLabel@3
                          , Codec.Json.Unidirectional.Value.DecodeError
                            ("Missing field")
                          )
                        )
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (@6#0)
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              , "foo":
                  \(lookupFn@2, recLabel@3) ->
                    let v@4 = lookupFn@2 recLabel@3 in
                    if #[prim.istag Data.Maybe.Nothing](v@4) thenData.Either.Right
                        (Data.Maybe.Nothing)
                    else if #[prim.istag Data.Maybe.Just](v@4) thenlet
                        @5 = Codec.Json.Unidirectional.Value.AtKey recLabel@3 in
                      let
                        @6 = Codec.Json.Unidirectional.Value.toBoolean v@4#0 in
                      if #[prim.istag Data.Either.Left](@6) thenData.Either.Left
                          (@5 @6#0)
                      else if #[prim.istag Data.Either.Right](@6) thenData.Either.Right
                          (Data.Maybe.Just(@6#0))
                      else 
                        #[prim.fail]()
                    else 
                      #[prim.fail]()
              } in
          \(lookupFn@3, recLabel@4) ->
            let v@5 = lookupFn@3 recLabel@4 in
            if #[prim.istag Data.Maybe.Nothing](v@5) thenData.Either.Left
                ( Codec.Json.Unidirectional.Value.AtKey
                  ( recLabel@4
                  , Codec.Json.Unidirectional.Value.DecodeError("Missing field")
                  )
                )
            else if #[prim.istag Data.Maybe.Just](v@5) thenlet
                @6 = Codec.Json.Unidirectional.Value.AtKey recLabel@4 in
              let @7 = Codec.Json.Unidirectional.Value.toJObject v@5#0 in
              let
                @8 =
                  if #[prim.istag Data.Either.Left](@7) thenData.Either.Left
                      (@7#0)
                  else if #[prim.istag Data.Either.Right](@7) thenlet
                      @8 = @1."toRecordObj" Type.Proxy.Proxy @2 @7#0 in
                    if #[prim.istag Data.Either.Left](@8) thenlet
                        v2@9 =
                          @2."foo"
                            ( \k@9 ->
                              Foreign.Object._lookup
                                (Data.Maybe.Nothing, Data.Maybe.Just, k@9, @7#0)
                            , "foo"
                            ) in
                      if #[prim.istag Data.Either.Left](v2@9) thenData.Either.Left
                          ( if
                            #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                              (@8#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                              (Data.List.Types.Cons(v2@9#0, @8#0#0))
                          else 
                            Codec.Json.Unidirectional.Value.AccumulateError
                              ( Data.List.Types.Cons
                                ( v2@9#0
                                , Data.List.Types.Cons
                                  (@8#0, Data.List.Types.Nil)
                                )
                              )
                          )
                      else 
                        Data.Either.Left(@8#0)
                    else if #[prim.istag Data.Either.Right](@8) then( if
                        #[prim.istag Data.Either.Left](@8) thenlet @9 = @8#0 in
                        \v@10 -> Data.Either.Left(@9)
                      else if #[prim.istag Data.Either.Right](@8) thenlet
                          @9 = @8#0 in
                        \f@10 -> f@10 @9
                      else 
                        #[prim.fail]()
                      )
                        ( \rec@9 ->
                          let
                            @10 =
                              @2."foo"
                                ( \k@10 ->
                                  Foreign.Object._lookup
                                    ( Data.Maybe.Nothing
                                    , Data.Maybe.Just
                                    , k@10
                                    , @7#0
                                    )
                                , "foo"
                                ) in
                          ( if #[prim.istag Data.Either.Left](@10) thenlet
                              @11 = @10#0 in
                            \v@12 -> Data.Either.Left(@11)
                          else if #[prim.istag Data.Either.Right](@10) thenlet
                              @11 = @10#0 in
                            \f@12 -> f@12 @11
                          else 
                            #[prim.fail]()
                          )
                            (\a@11 -> Data.Either.Right(rec@9 { "foo" = a@11 }))
                        )
                    else 
                      #[prim.fail]()
                  else 
                    #[prim.fail]() in
              if #[prim.istag Data.Either.Left](@8) thenData.Either.Left
                  (@6 @8#0)
              else if #[prim.istag Data.Either.Right](@8) thenData.Either.Right
                  (@8#0)
              else 
                #[prim.fail]()
            else 
              #[prim.fail]()
      } in
  \a@2 ->
    let @3 = Codec.Json.Unidirectional.Value.toJObject a@2 in
    if #[prim.istag Data.Either.Left](@3) thenData.Either.Left(@3#0)
    else if #[prim.istag Data.Either.Right](@3) thenlet
        @4 = @0."toRecordObj" Type.Proxy.Proxy @1 @3#0 in
      if #[prim.istag Data.Either.Left](@4) thenlet
          v2@5 =
            @1."nested"
              ( \k@5 ->
                Foreign.Object._lookup
                  (Data.Maybe.Nothing, Data.Maybe.Just, k@5, @3#0)
              , "nested"
              ) in
        if #[prim.istag Data.Either.Left](v2@5) thenData.Either.Left
            ( if
              #[prim.istag Codec.Json.Unidirectional.Value.AccumulateError]
                (@4#0) thenCodec.Json.Unidirectional.Value.AccumulateError
                (Data.List.Types.Cons(v2@5#0, @4#0#0))
            else 
              Codec.Json.Unidirectional.Value.AccumulateError
                ( Data.List.Types.Cons
                  (v2@5#0, Data.List.Types.Cons(@4#0, Data.List.Types.Nil))
                )
            )
        else 
          Data.Either.Left(@4#0)
      else if #[prim.istag Data.Either.Right](@4) then( if
          #[prim.istag Data.Either.Left](@4) thenlet @5 = @4#0 in
          \v@6 -> Data.Either.Left(@5)
        else if #[prim.istag Data.Either.Right](@4) thenlet @5 = @4#0 in
          \f@6 -> f@6 @5
        else 
          #[prim.fail]()
        )
          ( \rec@5 ->
            let
              @6 =
                @1."nested"
                  ( \k@6 ->
                    Foreign.Object._lookup
                      (Data.Maybe.Nothing, Data.Maybe.Just, k@6, @3#0)
                  , "nested"
                  ) in
            ( if #[prim.istag Data.Either.Left](@6) thenlet @7 = @6#0 in
              \v@8 -> Data.Either.Left(@7)
            else if #[prim.istag Data.Either.Right](@6) thenlet @7 = @6#0 in
              \f@8 -> f@8 @7
            else 
              #[prim.fail]()
            )
              (\a@7 -> Data.Either.Right(rec@5 { "nested" = a@7 }))
          )
      else 
        #[prim.fail]()
    else 
      #[prim.fail]()